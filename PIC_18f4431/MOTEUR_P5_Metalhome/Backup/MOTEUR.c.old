//******************************************************************************
//	PROGRAMME RSMM CHAINE CORDE CABLE
//  DATE LE 27/03/2017
//	FAIT PAR BERGER OLIVIER 
//******************************************************************************
#include <stdbool.h>
#include <xc.h>
//#include <time.h>
#include <stdlib.h>
#include "MOTEUR.h"
#include "Variables.h"

#include "adc.h"




#pragma warning disable 752

// CONFIG1H
#pragma config OSC = IRCIO      // Oscillator Selection bits (Internal oscillator block, port function on RA6 and port function on RA7)
#pragma config FCMEN = ON       // Fail-Safe Clock Monitor Enable bit (Fail-Safe Clock Monitor enabled)
#pragma config IESO = ON        // Internal External Oscillator Switchover bit (Internal External Switchover mode enabled)

// CONFIG2L
#pragma config PWRTEN = ON      // Power-up Timer Enable bit (PWRT enabled)
#pragma config BOREN = ON       // Brown-out Reset Enable bits (Brown-out Reset enabled)
#pragma config BORV = 42        // Brown Out Reset Voltage bits (VBOR set to 4.2V)

// CONFIG2H
#pragma config WDTEN = OFF      // Watchdog Timer Enable bit (WDT disabled (control is placed on the SWDTEN bit))
#pragma config WDPS = 32768     // Watchdog Timer Postscale Select bits (1:32768)
#pragma config WINEN = OFF      // Watchdog Timer Window Enable bit (WDT window disabled)

// CONFIG3L
#pragma config PWMPIN = OFF     // PWM output pins Reset state control (PWM outputs disabled upon Reset (default))
#pragma config LPOL = HIGH      // Low-Side Transistors Polarity (PWM0, 2, 4 and 6 are active-high)
#pragma config HPOL = HIGH      // High-Side Transistors Polarity (PWM1, 3, 5 and 7 are active-high)
#pragma config T1OSCMX = OFF    // Timer1 Oscillator MUX (Standard (legacy) Timer1 oscillator operation)

// CONFIG3H
#pragma config FLTAMX = RC1     // FLTA MUX bit (FLTA input is multiplexed with RC1)
#pragma config SSPMX = RC7      // SSP I/O MUX bit (SCK/SCL clocks and SDA/SDI data are multiplexed with RC5 and RC4, respectively. SDO output is multiplexed with RC7.)
#pragma config PWM4MX = RB5     // PWM4 MUX bit (PWM4 output is multiplexed with RB5)
#pragma config EXCLKMX = RC3    // TMR0/T5CKI External clock MUX bit (TMR0/T5CKI external clock input is multiplexed with RC3)
#pragma config MCLRE = OFF      // MCLR Pin Enable bit (Disabled)

// CONFIG4L
#pragma config STVREN = ON      // Stack Full/Underflow Reset Enable bit (Stack full/underflow will cause Reset)
#pragma config LVP = OFF        // Low-Voltage ICSP Enable bit (Low-voltage ICSP disabled)

// CONFIG5L
#pragma config CP0 = OFF        // Code Protection bit (Block 0 (000200-000FFFh) not code-protected)
#pragma config CP1 = OFF        // Code Protection bit (Block 1 (001000-001FFF) not code-protected)
#pragma config CP2 = OFF        // Code Protection bit (Block 2 (002000-002FFFh) not code-protected)
#pragma config CP3 = OFF        // Code Protection bit (Block 3 (003000-003FFFh) not code-protected)

// CONFIG5H
#pragma config CPB = OFF        // Boot Block Code Protection bit (Boot Block (000000-0001FFh) not code-protected)
#pragma config CPD = OFF        // Data EEPROM Code Protection bit (Data EEPROM not code-protected)

// CONFIG6L
#pragma config WRT0 = OFF       // Write Protection bit (Block 0 (000200-000FFFh) not write-protected)
#pragma config WRT1 = OFF       // Write Protection bit (Block 1 (001000-001FFF) not write-protected)
#pragma config WRT2 = OFF       // Write Protection bit (Block 2 (002000-002FFFh) not write-protected)
#pragma config WRT3 = OFF       // Write Protection bit (Block 3 (003000-003FFFh) not write-protected)

// CONFIG6H
#pragma config WRTC = OFF       // Configuration Register Write Protection bit (Configuration registers (300000-3000FFh) not write-protected)
#pragma config WRTB = OFF       // Boot Block Write Protection bit (Boot Block (000000-0001FFh) not write-protected)
#pragma config WRTD = OFF       // Data EEPROM Write Protection bit (Data EEPROM not write-protected)

// CONFIG7L
#pragma config EBTR0 = OFF      // Table Read Protection bit (Block 0 (000200-000FFFh) not protected from table reads executed in other blocks)
#pragma config EBTR1 = OFF      // Table Read Protection bit (Block 1 (001000-001FFF) not protected from table reads executed in other blocks)
#pragma config EBTR2 = OFF      // Table Read Protection bit (Block 2 (002000-002FFFh) not protected from table reads executed in other blocks)
#pragma config EBTR3 = OFF      // Table Read Protection bit (Block 3 (003000-003FFFh) not protected from table reads executed in other blocks)

// CONFIG7H
#pragma config EBTRB = OFF      // Boot Block Table Read Protection bit (Boot Block (000000-0001FFh) not protected from table reads executed in other blocks)


//#define INDICE_SIGMOIDE 15
#define INDICE_SIGMOIDE 15

// #pragma config statements should precede project file includes.
// Use project enums instead of #define for ON and OFF.

//****************************************************************************** 
//	FONCTION INITIALISATION IT
//******************************************************************************

unsigned char Image_Courant_Moteur_1;
bit Nouvelle_Valeur_ADC;


void Init_IT(void) {
    INTCON = 0b11010000; //GLOBAL IT,PERIPHERAL IT,TMROIE,INT0IE,RBIETMR0IF,INT0IF,RBIF
    INTCON2 = 0b11110101; //PULL UP, INTEDG0,INTEDG1,TMR0IP,RBIP
    INTCON3 = 0b11001000; //  
    INTCON3 = 0b01001000; //  
    //PIR1= 0b01000000
    
//    INTCONbits.GIEH=1;//GIEH
//    INTCONbits.GIEL=1;
//    //équivaut à
//    INTCONbits.GIE=1;//GIEH
//    INTCONbits.PEIE=1;
    
    
}

//******************************************************************************
//	FONCTION INTERRUPTION HIGH PRIORITY 
//******************************************************************************

void interrupt high_priority test1(void) {

    //if((INT0IF ==  1)||(INT1IF ==  1)) // IT COUPURE SECTEUR BLOQUANT 
    
//    if(PIR1bits.ADIF==1){
//////    if(ADIF==1){
//////        LED=1;
//////        ADIF=0;
//////Nouvelle_Valeur_ADC = 1;
//////        Image_Courant_Moteur_1 = ADRESH;
//////        LED=0;
//////    }
//////    
////////    else if(PTIF == 1){
////////        //PTIF=0;
////////        
////////        
////////    }
//////    
//////    
//////    else 
//////        
//////        
        
        if (INT0IF == 1) // IT COUPURE SECTEUR BLOQUANT 
    {
            INT0IF =0;
//        DRIVER_M1 = 0;
//        DRIVER_M2 = 0;
//        OVDCOND = 0b00000000;
//        LED = 0;
//        while (1)
//            
//        {LED = 0;
//        LED = 0;
//        LED = 0;
//        LED = 0;
//        LED = 1;}
    }

}


//****************************************************************************** 
//	FONCTION INITIALISATION ADC
//******************************************************************************

void Init_ADC(void) {
    ADCON0 = 0b00000000;
    ADCON1 = 0b00000000; /*ENTREE SORTIE DIGITALE */
    ADCON2 = 0b10010100; // TAD = 1 us F:4 TACQ = 4*TAD
    ADCON3 = 0b11000000;
    ADCHS = 0b00000000;
    ANSEL0 = 0b00000011;
    //ANSEL0 = 0b00001111; // + DAC
    ANSEL1 = 0b00000000;
    ADON = 1;

}


//****************************************************************************** 
//	FONCTION INITIALISATION ADC
//******************************************************************************

void Init_ADC_PWM_Trig(void) {
//    ADCON0 = 0b00100000;//
    //ADCON0 = 0b00100000;//Single Shot
    ADCON0 = 0b10100000;//Continuous
    ADCON1 = 0b00000000; /*ENTREE SORTIE DIGITALE */
    ADCON2 = 0b10010100; // TAD = 1 us F:4 TACQ = 4*TAD
//    ADCON3 = 0b11010000;
    ADCON3 = 0b00010000;
    //ADCON3 = 0b00010000;
    ADCHS = 0b00000000;
    ANSEL0 = 0b00000011;
    //ANSEL0 = 0b00001111; // + DAC
    ANSEL1 = 0b00000000;
    
    
//    
//    PIE1bits.ADIE = 1;
//    IPR1bits.ADIP = 1;
//    IPR3bits.PTIP = 1;
//    RCONbits.IPEN = 1;
//    
    
    
    
    
    ADON = 1;
Nouvelle_Valeur_ADC = 0;
ADIF=0;

}
//****************************************************************************** 
//	FONCTION INITIALISATION ADC
//******************************************************************************

void Init_ADC_PWM(void) {
//    ADCON0 = 0b00100000;//
    ADCON0 = 0b00000000;//Single Shot
   // ADCON0 = 0b10100000;//Continuous
    ADCON1 = 0b00000000; /*ENTREE SORTIE DIGITALE */
    ADCON2 = 0b10010100; // TAD = 1 us F:4 TACQ = 4*TAD
//    ADCON3 = 0b11010000;
    ADCON3 = 0b00000000;
    //ADCON3 = 0b00010000;
    ADCHS = 0b00000000;
    ANSEL0 = 0b00000011;
    //ANSEL0 = 0b00001111; // + DAC
    ANSEL1 = 0b00000000;
    
    
//    
//    PIE1bits.ADIE = 1;
//    IPR1bits.ADIP = 1;
//    IPR3bits.PTIP = 1;
//    RCONbits.IPEN = 1;
//    
    
    
    
    
    ADON = 1;
Nouvelle_Valeur_ADC = 0;
ADIF=0;

}
//****************************************************************************** 
//	FONCTION INITIALISATION ENTREE SORTIE
//******************************************************************************

void Init_Port(void) {
    /*sortie 0 entree 1*/


    TRISA = 0b11111111;
    TRISB = 0b11111010;
    TRISC = 0b11011100;
    TRISD = 0b00001111;
    TRISE = 0b00000111;

    LATA = 0b00000000;
    LATB = 0b00000000;
    LATC = 0b00000000;
    LATD = 0b00000001;
    LATE = 0b00000000;

}
//****************************************************************************** 
//	FONCTION INIT TIMER2
//******************************************************************************

void Init_TIMER2(void) {
    T2CON = 0b00000100;
    PR2 = 200;
}
//****************************************************************************** 
//	FONCTION INIT PWM
//******************************************************************************

void Init_PWM(void) {
    PTPERL = 99;
    PTPERH = 0;

    PTCON0 = 0b00000000; // POSTSCALE 1,PRESCALE 1,MODE 
    PTCON1 = 0b10000000; // PWM TIME BASE,DIRECTION

    PWMCON0 = 0b00111111;
    PWMCON1 = 0b00000000;

    DTCON = 0b00000000;
    OVDCOND = 0b00000101;
    OVDCONS = 0b00000000;

    
    
//    void Init_PWM(void)
//{   
//    int duty;
//   
//   
//    PDC0L  =(char)(duty << 2);
//    PDC0H  =(char)((duty << 2)>>8);
//           
//    duty = 20;
//    PDC1L  =(char)(duty << 2);
//    duty =  30;
//    PDC1H  =(char)((duty << 2)>>8);
   // while();
//}
    
    
    
    
}
//****************************************************************************** 
//	FONCTION INIT PWM
//******************************************************************************

void u_Init_PWM(void) {
    //PTPERL = 99;
    //PTPERL = 0x0f;
    //PTPERL = 0x7f;
    PDC0L = 1<<2;
    PDC0H = 0;

//    PTPERL = 0x63;
//    PTPERL = 0x0f; //marche - 16
//    PTPERL = 50;
//    PTPERL = 250; //marche
//    PTPERL = 0x20; //marche pas
//    PTPERL = 255;
    PTPERL = (0xff) >> 3; // = 0x1F = 32
   // PTPERL = (0xff) >> 2; // = 0x1F = 32
    //PTMRL = PTPERL;
    //PTPERL = 0x0f;
    //PTPERL = 0xff;
    //PTPERL = 0x15;
    PTPERH = 0;
    // PTMRH = PTPERH;

    //PTCON0 = 0b00000000; // POSTSCALE 1,PRESCALE 1,MODE 
    //    PTCON0bits.PTMOD0 = 1
    //    PTCON0bits.PTMOD1 = 1

    PTCON0 = 0b00000011; // POSTSCALE 1,PRESCALE 1,MODE 


    PTCON1 = 0b10000000; // PWM TIME BASE,DIRECTION

    PWMCON0 = 0b00111111;
    
    
    PWMCON1 = 0b00000000;
PWMCON1 = 0b00000001;//

    DTCON = 0b00000000;
    OVDCOND = 0b00000101;
    OVDCONS = 0b00000000;
    
    
    
   // PIE3bits.PTIE = 1;
    
    SEVTDIR=0;
    SEVTCMPH = 0;
    SEVTCMPL = 0;
    
    
    
    
    
    
    

}
//******************************************************************************
//		FONCTION LECTURE AN0 GA
//******************************************************************************

             /*unsigned*/ int lecture_I_Mot1(void) {
    volatile static /* unsigned */ int Resul;

    ADCON0 = 0b00000001; //  RA0
    ADCON2 = 0b10010100; // TAD = 1 us F:4 TACQ = 4*TAD
    //ADCON3 = 0b11000000;
    //ADON = 1;
    GODONE = 1;
    while (GODONE == 1);
    Resul = ADRESH;
    Resul = (Resul << 8) + ADRESL;
    NOP();
    NOP();
    NOP();
    NOP();
    NOP();
    NOP();
    return Resul;
}

void u_lecture_I_Mot1_init(void) {

    ADCON0 = 0b00000001; //  RA0
    //ADCON2 = 0b10010100; // TAD = 1 us F:4 TACQ = 4*TAD //Rigth justified
    ADCON2 = 0b00010100; // TAD = 1 us F:4 TACQ = 4*TAD // Left justified

}

unsigned char u_lecture_I_Mot1(void) {
    // volatile static unsigned char Resul;

    //    ADCON0 = 0b00000001; //  RA0
    //    ADCON2 = 0b10010100; // TAD = 1 us F:4 TACQ = 4*TAD

    //    ADCON0 = 0b00000001; //  RA0
    //    //ADCON2 = 0b10010100; // TAD = 1 us F:4 TACQ = 4*TAD //Rigth justified
    //    ADCON2 = 0b00010100; // TAD = 1 us F:4 TACQ = 4*TAD // Left justified
    // ADCON2 = 0b00001000; // TAD = 1 us F:4 TACQ = 4*TAD // Left justified
    //ADCON3 = 0b11000000;
    //ADON = 1;
    LED = 1;
    GODONE = 1;
    //LED = 1;
    while (GODONE == 1);
    LED = 0;
    //    Resul = ADRESH;
    //    Resul = (Resul << 8) + ADRESL;
    //    NOP();
    //    NOP();
    //    NOP();
    //    NOP();
    //    NOP();
    //    NOP();
    //return Resul;
    return ADRESH;
}


//******************************************************************************
//		FONCTION LECTURE AN1 GB
//******************************************************************************

int lecture_I_Mot2(void) {
    volatile static int Resul;

    ADCON0 = 0b00000100; //  RA0
    ADCON2 = 0b10010100; // TAD = 1 us F:4 TACQ = 4*TAD
    ADON = 1;
    GODONE = 1;
    while (GODONE == 1);
    Resul = ADRESH;
    Resul = (Resul << 8) + ADRESL;
    NOP();
    NOP();
    NOP();
    NOP();
    NOP();
    NOP();
    return Resul;
}

//******************************************************************************
// FONCTION  MOTEUR1 AV
//******************************************************************************

void Moteur1_AV(int consigne) {
    /*unsigned */int i;
    int erreur;
    int duty = 0;


    //Init_PWM();


    AV_M1;
    PDC0L = 0;
    PDC0H = 0;
    OVDCOND = 0b00000001;
    DRIVER_M1 = 1;


    TMR2 = 0;
    TMR2IF = 0;
    do {
        if (TMR2IF == 1) {
            TMR2IF = 0;
            i = lecture_I_Mot1();
            erreur = consigne - i;
            //   erreur = erreur * 3;
            //erreur = erreur >> 4;
            erreur = erreur >> 3;
            duty = erreur;
            //            if (erreur > 0){
            //            duty =  100;}
            if (duty > 100) duty = 100;
            else if (duty < 0) duty = 0;
            PDC0L = (char) (duty << 2);
            PDC0H = (char) ((duty << 2) >> 8);
        }
    } while (AV_1 == 1); //AV_1
    DRIVER_M1 = 0;
    OVDCOND = 0b00000000;
    STOP_M1;
    //  LED = 0;
}

//******************************************************************************
// FONCTION  MOTEUR1 AV
//******************************************************************************

void u_Moteur1_AV(unsigned char consigne) {
    unsigned char i; //, i_min, i_max;
    unsigned char erreur;
    
    //    unsigned int duty = 0;
    unsigned char duty;
    unsigned int index;
    unsigned char direction;
    // bit Unique;

    //unsigned char 

    u_Init_PWM();
    u_lecture_I_Mot1_init();
Init_ADC_PWM();

    index = 0;

    TMR2 = 0;
    TMR2IF = 0;
    
    
    
    AV_M1;
    PDC0L = 1<<2;
    PDC0H = 0;
    OVDCOND = 0b00000001;
    DRIVER_M1 = 1;

/*
 Ajout seconde PWM
 */
//    
//    PDC1L = 1<<2;
//    PDC1H = 0;
//    
//        i = 25;
//        i = 15;
//            PDC1L = (char) (25 << 2);
//            PDC1H = 25 >> 6;
//    //OVDCOND = 0b00000101; 
//    AV_M2;
//    OVDCOND = 0b00000101; 
//    DRIVER_M2 = 1;
//    
//    while(1){
//        LED =1;
//        LED =0;
//        
//    }
/*
 Ajout seconde PWM
 */
    

    //    //erreur=3;
    //    erreur = 31;
    //    //erreur = 0;
    //    u_lecture_I_Mot1_init();
    //    PTIF = 0;
    //    while (PTIF == 0) NOP();
    //    PTIF = 0;

    //erreur = 31;
    //erreur = 5;
    erreur = 31;
    erreur = 31;
    PDC0L = erreur << 2;
    PDC0H = erreur >> 6;
    
////////     PIE3bits.PTIE = 1;
//////    do{
//////    
//////        //LED = ADIF;
//////       // ADIF=0;
////////        if(ADIF == 1){
////////        LED = 1;
////////        ADIF=0;
////////        }else{
////////            LED=0;
////////        }
//////         LED=0;
//////          LED=1;
//////////////        if(PTIF == 1){
//////////////        LED = 1;
//////////////        PTIF=0;
//////////////        }else{
//////////////            LED=0;
//////////////        }
////////        LED = 1;
////////        LED = 0;
//////    }
//////    while(AV_1 == 1);
//////    
//////    
//////    
////////     while (AV_1 == 1); //AV_1
//////     
//////    DRIVER_M1 = 0;
//////    OVDCOND = 0b00000000;
//////    STOP_M1;
////////    PDC0L = 0;
////////    PDC0H = 0;
//////    //while(1);//
//////     return;
//////    
//////    //    do{
//////    //    LED=PTIF;
//////    //    PTIF=0;
//////    ////    LED=PTDIR;
//////    //////    PTIF=0;
//////    //    }while (AV_1 == 1);
//////    GODONE = 1;
//////    PIE3bits.PTIE = 1;
//////    do{
//////    
//////        //LED = ADIF;
//////       // ADIF=0;
////////        if(ADIF == 1){
////////        LED = 1;
////////        ADIF=0;
////////        }else{
////////            LED=0;
////////        }
//////        if(PTIF == 1){
//////        LED = 1;
//////        PTIF=0;
//////        }else{
//////            LED=0;
//////        }
////////        LED = 1;
////////        LED = 0;
//////    }
//////    while(1);
//////        
//////        
//////        
    
    
//    
//    do {
//    
//        while(Nouvelle_Valeur_ADC==0);
//        Nouvelle_Valeur_ADC=0;
//        
//    
//    } while (AV_1 == 1); //AV_1
//    
    //RB0 = 1;
    while (PTDIR == 1) NOP();
    while (PTDIR == 0) NOP();
LED = 1;
    do {

        if (PTDIR == 1) {
        //if (PTDIR == 0) {
            if (erreur > INDICE_SIGMOIDE){
            while (PTDIR == 1) NOP();
            }
        } else {
            if (erreur <= INDICE_SIGMOIDE){
            while (PTDIR == 0) NOP();
            }
        }


        i = u_lecture_I_Mot1();

        if (i >= consigne) {
            //erreur = 0;//Consigne atteinte ou dépassé => On n'envoi pas de courant
            erreur = 1; //Consigne atteinte ou dépassé => On n'envoi pas de courant
        } else {
            erreur = consigne - i;
            //erreur = erreur >> 3;//Fonctionnement attendu
           // erreur = erreur >> 3;//Fonctionnement attendu
            //erreur = erreur >> 4;
            erreur = erreur >> 1;
            //erreur = erreur >> 2;//Fonctionnement test pleine onde
            if (erreur >= 32) erreur = 31; // Vakeur max pour le registre de la PWM => on maximise sans atteindre
            //if (erreur >= 31) erreur = 30; // Vakeur max pour le registre de la PWM => on maximise sans atteindre
        }


   // erreur = 31;//Test pleine onde //DEBUG
        PDC0L = erreur << 2;
        PDC0H = erreur >> 6;

        //i = i>>3;
        //i = 15;
       // i=i>>3;//Normal
        //i=i>>2;//X2
//            PDC1L = (char) (i << 2);
//            PDC1H = i >> 6;

        //        if(erreur>15){
        //            
        //            
        //        }else{
        //            
        //        }
        //        


        //    PTIF = 0;
        //    while (PTIF == 0) NOP();
        //    PTIF = 0;


        //PDC0L = 0x02;
        //        if (TMR2IF == 1) {
        //            TMR2IF = 0;
        //while(PTDIR==0) PTIF = 0;
        //        while(PTDIR==0) NOP();
        //        if ((PTIF == 1) && (PTDIR=1) ){
        ////////        while(PTDIR==1) NOP();
        ////////        if ((PTIF == 1) && (PTDIR==0)){
        //        while(PTDIR==0) NOP();
        //        if ((PTIF == 1) && (PTDIR==1)){

        //if(erreur>2) direction = 0; else direction =1;
        //if (erreur > 16) direction = 0; else direction = 1; //permet un déclenchement de la mesure suivant la valeur de duty cycle de la PWM
        //if (erreur > 20) {direction = 0; }else{ direction = 1;} //permet un déclenchement de la mesure suivant la valeur de duty cycle de la PWM
        //direction = 1;//PWM == Etat Bas
        //direction = 0;//PWM == Etat Haut
        // if(erreur>4) direction = 1; else direction =0;
        //while(PTDIR==direction) NOP();
        //direction=1;

        //        if (PTDIR != direction) {
        //            // while(PTDIR!=direction) PTIF = 0;
        //            while (PTIF == 0) NOP();
        //            while (PTIF == 0) NOP();
        //        } else {
        //            while (PTIF == 0) NOP();
        //        }
        //
        //        if (erreur > 16) {
        //
        //        } else {
        //
        //        }


        //
        //        if (PTDIR == 1) {//décrémente le compteur
        //            // while(PTDIR!=direction) PTIF = 0;
        //            if (erreur > 16) {
        //                while (PTIF == 0) NOP();
        //                PTIF = 0;
        //                while (PTIF == 0) NOP();
        //                PTIF = 0;
        //            } else {
        ////                while (PTIF == 0) NOP();
        ////                PTIF = 0;
        //                while (PTIF == 0) NOP();
        //                PTIF = 0;
        //            }
        //        } else {
        //            if (erreur > 16) {
        ////                while (PTIF == 0) NOP();
        ////                PTIF = 0;
        //                while (PTIF == 0) NOP();
        //                PTIF = 0;
        //            } else
        //                while (PTIF == 0) NOP();
        //                PTIF = 0;
        //                while (PTIF == 0) NOP();
        //                PTIF = 0;
        //        }

        //
        //        if (PTDIR == 1) {//décrémente le compteur
        //            // while(PTDIR!=direction) PTIF = 0;
        //            if (erreur > 16) {
        //                while (PTDIR == 1) NOP();
        //                //PTIF = 0;
        ////                while (PTIF == 0) NOP();
        ////                PTIF = 0;
        //            } 
        ////            else {
        //////                while (PTIF == 0) NOP();
        //////                PTIF = 0;
        ////                while (PTIF == 0) NOP();
        ////                PTIF = 0;
        ////            }
        //        } else {
        //            if (erreur > 16) {
        ////                while (PTIF == 0) NOP();
        ////                PTIF = 0;
        //                while (PTIF == 0) NOP();
        //                PTIF = 0;
        //            } else
        //                while (PTIF == 0) NOP();
        //                PTIF = 0;
        //                while (PTIF == 0) NOP();
        //                PTIF = 0;
        //        }

        //                while (PTIF == 0) NOP();
        //                PTIF = 0;

        //if (PTDIR == direction) {
        //while (PTDIR == direction) PTIF = 0;
        //if ((PTIF == 1) && (PTDIR != direction)) {
        //        
        //        while(PTDIR==1) NOP();
        //        if ((PTIF == 1) && (PTDIR==0)){


        // index+=1;
        //if ((PTIF == 1) && (PTDIR=0) ){
        //PTIF = 0;

        //            LED = 1;
        //index+=1;
        //        i = u_lecture_I_Mot1();
        //            LED = 0;
        // i = (i>>1)<<1;
        //i = i>>4;
        //i = i>>2;


        //i = i>>2;



        //            if (i>i_max) i_max=i;
        //            if (i<i_min) i_min=i;

        //        if (i >= consigne) {
        //            //erreur = 0;//Consigne atteinte ou dépassé => On n'envoi pas de courant
        //            erreur = 1; //Consigne atteinte ou dépassé => On n'envoi pas de courant
        //        } else {
        //            erreur = consigne - i;
        //            erreur = erreur >> 3;
        //            //if (erreur >= 32) erreur = 31; // Vakeur max pour le registre de la PWM => on maximise sans atteindre
        //            //if (erreur >= 31) erreur = 30; // Vakeur max pour le registre de la PWM => on maximise sans atteindre
        //        }
        //PDC0L = erreur;

        // i ^= i;

        //PDC0L = 0x32;//50
        //PDC0L = 0x64;//100

        //PDC0L = 0x08;
        //PDC0L = 0x0A;

        //PDC0L = (~i)>>4;
        //PDC0L = (0xff-i)>>6;
        //PDC0L = (0xff-i);
        ////////            i=0xff-i;
        ////////            i=0xff-i;
        //i=i>>3;//
        //i=i>>4;//
        //i = i & 0x1f;
        ////////            i = i & 0x1f;
        //PDC0L = i  & 0x0f;
        ////////            PDC0L = i;//  & 0x0f;
        //            PDC0L = 3;//  & 0x0f;
        ////////            duty = (0xff)>>4;
        ////////            
        ////////            PDC0L = (char) (duty << 2);
        ////////            PDC0H = (char) ((duty << 2) >> 8);
        //            duty = erreur;
        //            //duty = duty & 0x1f;
        //            PDC0L = (duty | 0x01)<<2;
        //            PDC0H = duty >> 6;


        //PDC0L = (erreur | 0x01)<<2;
        //erreur  = 0xff >> 3;
        //erreur = 30;
        //        PDC0L = erreur << 2;
        //        PDC0H = erreur >> 6;
        // PDC0L = 0xc4;
        // PDC0H = 0;
        //PDC0L = 0x1f;
        //////            PDC0L = 0x08;
        //PDC0L = (~i);
        // PDC0L =~(i>>2);
        //PDC0L = 0x1F;
        //PDC0L = 0x20;
        //PDC0L = 0xff;
        // PDC0L = 0x07;
        //PDC0H = 0x01;
        // PDC0L = 0x0f;
        //PDC0L = index >> 4;
        //PDC0L += 1;
        //PTPERL = 0x0F;
        //PTPERL = ~i;
        //PTPERL = 0x0f;
        //PTMRL = 0x1F;


        // }


        // LED = 0;
        //PTIF = 0;
        //            PDC0L = (char) (duty << 2);
        //            PDC0H = (char) ((duty << 2) >> 8);
        //    }
        // }


        // } while (1); //AV_1
    } while (AV_1 == 1); //AV_1
    LED = 0;
    DRIVER_M1 = 0;
    OVDCOND = 0b00000000;
    STOP_M1;
    //  LED = 0;
}

//******************************************************************************
// FONCTION  MOTEUR1 AR
//******************************************************************************

void Moteur1_AR(int consigne) {
    /*unsigned */ int i;
    int erreur;
    int duty = 0;


    Init_PWM();
    AR_M1;
    PDC0L = 0;
    PDC0H = 0;
    OVDCOND = 0b00000001;
    DRIVER_M1 = 1;
    TMR2 = 0;
    TMR2IF = 0;
    do {
        if (TMR2IF == 1) {
            TMR2IF = 0;
            LED = 1;
            i = lecture_I_Mot1();
            erreur = consigne - i;
            //  erreur = erreur * 3;
            erreur = erreur >> 2;
            duty = erreur;
            if (duty > 100) duty = 100;
            else if (duty < 0) duty = 0;
            //duty = 100;//DEBUG
            PDC0L = (char) (duty << 2);
            PDC0H = (char) ((duty << 2) >> 8);
            LED = 0;
        }
    } while (AR_1 == 1);
    DRIVER_M1 = 0;
    OVDCOND = 0b00000000;
    STOP_M1;
}
//******************************************************************************
// FONCTION  MOTEUR1 AV
//******************************************************************************

void Moteur2_AV(int consigne) {
    int i;
    int erreur;
    int duty = 0;
    PDC1L = 0;
    PDC1H = 0;
    AV_M2;

    OVDCOND = 0b00000100;
    DRIVER_M2 = 1;
    TMR2 = 0;
    TMR2IF = 0;
    do {
        if (TMR2IF == 1) {
            i = lecture_I_Mot2();
            erreur = consigne - i;
            erreur = erreur * 3;
            erreur = erreur >> 5;
            duty = erreur;
            if (duty > 100) duty = 100;
            else if (duty < 0) duty = 0;
            PDC1L = (char) (duty << 2);
            PDC1H = (char) ((duty << 2) >> 8);
        }
    } while (AV_2 == 1);
    DRIVER_M2 = 0;
    OVDCOND = 0b00000000;
    STOP_M2;

}
//******************************************************************************
// FONCTION  MOTEUR1 AV
//******************************************************************************

void Moteur2_AR(int consigne) {
    int i;
    int erreur;
    int duty = 0;
    PDC1L = 0;
    PDC1H = 0;
    AR_M2;

    OVDCOND = 0b00000100;
    DRIVER_M2 = 1;
    TMR2 = 0;
    TMR2IF = 0;
    do {
        if (TMR2IF == 1) {
            i = lecture_I_Mot2();
            erreur = consigne - i;
            erreur = erreur * 3;
            erreur = erreur >> 5;
            duty = erreur;
            if (duty > 100) duty = 100;
            else if (duty < 0) duty = 0;
            PDC1L = (char) (duty << 2);
            PDC1H = (char) ((duty << 2) >> 8);
        }

    } while (AR_2 == 1);
    DRIVER_M2 = 0;
    OVDCOND = 0b00000000;
    STOP_M1;
}
//******************************************************************************
// FONCTION CYCLE MOTEUR
//******************************************************************************

void Cycle_Moteur(void) {
    //unsigned int duty;
    unsigned char Test_Inversion;
    while (1) {
        
    Init_PWM();
    Init_ADC();
        //if(AV_1 == 1) Moteur1_AV(120);
        // if (AV_1 == 1) Moteur1_AV(150);

        //        duty = 50;
        //            PDC0L = (char) (duty << 2);
        //            PDC0H = (char) ((duty << 2) >> 8);
        // u_Moteur1_AV(500);
        //if (AV_1 == 1) u_Moteur1_AV(500);
        //if (AV_1 == 1) u_Moteur1_AV(20);//uchar 20 unité => 8 A (8A*255uchar/100A); G = 20
        // if (AV_1 == 1) u_Moteur1_AV(27);//uchar 27 unité => 8 A (8A*255uchar/75A); G = 15
        //if (AV_1 == 1) u_Moteur1_AV(50);//uchar 27 unité => 8 A (8A*255uchar/75A); G = 15
        //        if (AV_1 == 1) u_Moteur1_AV(100);
        //        else if (AR_1 == 1) Moteur1_AR(120);
        //        Test_Inversion = 0x55;
        //        Test_Inversion ^= Test_Inversion;
        //        PDC1L = Test_Inversion;
        //if (AV_1 == 1) u_Moteur1_AV(50);//256
        //if (AV_1 == 1) u_Moteur1_AV(100);//256
        //if (AV_1 == 1) u_Moteur1_AV(10);//256
        //if (AV_1 == 1) u_Moteur1_AV(10);//256
        //if (AV_1 == 1) u_Moteur1_AV(17);//256
        //if (AV_1 == 1) u_Moteur1_AV(30); //256
        //if (AV_1 == 1) u_Moteur1_AV(20); //256
        //if (AV_1 == 1) u_Moteur1_AV(15); //256
        //if (AV_1 == 1) u_Moteur1_AV(80); //256
        //if (AV_1 == 1) u_Moteur1_AV(255); //256
        //if (AV_1 == 1) u_Moteur1_AV(255); //256
       // if (AV_1 == 1) u_Moteur1_AV(160); //256
        //if (AV_1 == 1) u_Moteur1_AV(60); //256
        //if (AV_1 == 1) u_Moteur1_AV(80); //256
        //if (AV_1 == 1) u_Moteur1_AV(255); //256
        if (AV_1 == 1) u_Moteur1_AV(44); //256 // 13 A
       // if (AV_1 == 1) u_Moteur1_AV(88); //256 // 20 A
        //if (AV_1 == 1) u_Moteur1_AV(176); //256 // 25 A
        //if (AV_1 == 1) u_Moteur1_AV(300); //256
            //if (AV_1 == 1) u_Moteur1_AV(10); //256
        else if (AR_1 == 1) Moteur1_AR(240); //1024
        else if (AV_2 == 1) Moteur2_AV(100);
        else if (AR_2 == 1) Moteur2_AR(100);
    }

}




//******************************************************************************
// FONCTION MAIN  OK
//******************************************************************************

void main(void) {
    OSCCON = 0b01100000; // 4 MHZ 
    while (IOFS != 1);


    Init_Port();
    Init_ADC();
    
    
    Init_TIMER2();
    //LED = 1;
    Init_PWM();
    Init_IT();
    Cycle_Moteur();

}
//******************************************************************************



